<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å½±äººåˆä½œç½‘ç»œå¯è§†åŒ–</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.2/dist/echarts.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(90deg, #2c3e50, #3498db);
            color: white;
            padding: 20px;
            text-align: center;
        }
        .header h1 {
            font-size: 2.2em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        .controls {
            background: #f8f9fa;
            padding: 15px 20px;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .control-group label {
            font-weight: bold;
            color: #495057;
        }
        select, input, button {
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-size: 14px;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: #0056b3;
        }
        .chart-container {
            display: flex;
            height: 700px;
        }
        #mainChart {
            flex: 3;
            height: 100%;
        }
        .sidebar {
            flex: 1;
            background: #f8f9fa;
            border-left: 1px solid #e9ecef;
            padding: 20px;
            overflow-y: auto;
            max-height: 700px;
        }
        .stats-panel {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        .stats-panel h3 {
            color: #2c3e50;
            margin-bottom: 10px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            padding: 5px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .highlight {
            background: #e3f2fd !important;
            font-weight: bold;
        }
        .tooltip-content {
            max-width: 300px;
        }
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
            font-size: 1.2em;
            color: #666;
        }
        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
        }
        .footer {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            color: #6c757d;
            border-top: 1px solid #e9ecef;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¬ å½±äººåˆä½œç½‘ç»œåˆ†æç³»ç»Ÿ</h1>
            <p>åŸºäºè±†ç“£ç”µå½±æ•°æ®çš„å½±äººåˆä½œå…³ç³»å¯è§†åŒ–åˆ†æ</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="layoutSelect">å¸ƒå±€ç®—æ³•ï¼š</label>
                <select id="layoutSelect">
                    <option value="force">åŠ›å¯¼å‘å¸ƒå±€</option>
                    <option value="circular">ç¯å½¢å¸ƒå±€</option>
                    <option value="none">å›ºå®šä½ç½®</option>
                </select>
            </div>
            <div class="control-group">
                <label for="nodeSize">èŠ‚ç‚¹å¤§å°ï¼š</label>
                <input type="range" id="nodeSize" min="5" max="50" value="20">
            </div>
            <div class="control-group">
                <label for="minCoop">æœ€å°åˆä½œæ¬¡æ•°ï¼š</label>
                <input type="number" id="minCoop" min="1" max="10" value="1">
            </div>
            <div class="control-group">
                <label for="maxRating">æœ€å¤§è¯„åˆ†ï¼š</label>
                <input type="number" id="maxRating" min="1" max="10" value="10" step="0.5">
            </div>
            <button onclick="applyFilters()">åº”ç”¨ç­›é€‰</button>
            <button onclick="resetFilters()">é‡ç½®</button>
            <button onclick="exportImage()">å¯¼å‡ºå›¾ç‰‡</button>
            <div class="control-group">
                <label for="searchInput">æœç´¢å½±äººï¼š</label>
                <input type="text" id="searchInput" placeholder="è¾“å…¥æ¼”å‘˜æˆ–å¯¼æ¼”å§“å">
                <select id="roleFilter">
                    <option value="all">æ¼”å‘˜ + å¯¼æ¼”</option>
                    <option value="actor">åªæœç´¢æ¼”å‘˜</option>
                    <option value="director">åªæœç´¢å¯¼æ¼”</option>
                </select>
                <button onclick="searchPerson()">æœç´¢</button>
                <button onclick="resetGraph()">é‡ç½®</button>
            </div>


        </div>

        <div class="chart-container">
            <div id="mainChart"></div>
            <div class="sidebar">
                <div class="stats-panel">
                    <h3>ğŸ“Š ç½‘ç»œç»Ÿè®¡</h3>
                    <div id="networkStats" class="loading">åŠ è½½ä¸­...</div>
                </div>
                <div class="stats-panel">
                    <h3>ğŸ¯ å…³é”®å‘ç°</h3>
                    <div id="keyInsights" class="loading">åŠ è½½ä¸­...</div>
                </div>
                <div class="stats-panel">
                    <h3>ğŸ¨ å›¾ä¾‹è¯´æ˜</h3>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #ff6b6b;"></div>
                            <span>å¯¼æ¼”</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #4ecdc4;"></div>
                            <span>æ¼”å‘˜</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #45b7d1;"></div>
                            <span>ç¼–å‰§</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #96ceb4;"></div>
                            <span>å…¶ä»–</span>
                        </div>
                    </div>
                </div>
                <div class="stats-panel">
                    <h3>ğŸ¬ æ–°ç”µå½±è¯„åˆ†é¢„æµ‹</h3>

                    <label>å¯¼æ¼”ï¼ˆç”¨ / åˆ†éš”ï¼‰</label>
                    <input id="directorsInput"
                           placeholder="å¼ è‰ºè°‹/é™ˆå‡¯æ­Œ"
                           style="width:100%;margin-bottom:8px;">

                    <label>æ¼”å‘˜ï¼ˆç”¨ / åˆ†éš”ï¼‰</label>
                    <input id="actorsInput"
                           placeholder="å·©ä¿/è‘›ä¼˜"
                           style="width:100%;margin-bottom:8px;">

                    <label>å…³ç³»æƒé‡</label>
                    <input type="range"
                           id="relationWeight"
                           min="0" max="1" step="0.1"
                           value="0.2"
                           style="width:100%;">

                    <button style="margin-top:10px;width:100%;"
                            onclick="predictMovie()">
                        é¢„æµ‹è¯„åˆ†
                    </button>

                    <div id="predictResult"
                         style="margin-top:10px;font-size:14px;">
                    </div>
                </div>
            </div>
        </div>

        <div class="footer">
            <p>æ•°æ®æ¥æºï¼šè±†ç“£ç”µå½± | å¯è§†åŒ–æŠ€æœ¯ï¼šECharts | ç”Ÿæˆæ—¶é—´ï¼š<span id="currentTime"></span></p>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let chart = null;
        let originalData = null;
        let currentData = null;

        // åˆå§‹åŒ–å›¾è¡¨
        function initChart() {
            const chartDom = document.getElementById('mainChart');
            chart = echarts.init(chartDom);

            // ç›´æ¥åŠ è½½æ•°æ®å¹¶æ˜¾ç¤º
            loadNetworkData();

            // å“åº”çª—å£å¤§å°å˜åŒ–
            window.addEventListener('resize', function() {
                chart.resize();
            });

            // æ˜¾ç¤ºå½“å‰æ—¶é—´
            document.getElementById('currentTime').textContent = new Date().toLocaleString();
        }
        function searchPerson() {
            const rawInput = document.getElementById('searchInput').value.trim();
            const mode = document.getElementById('roleFilter').value;
            // director | actor | all

            if (!rawInput) return;

            const names = rawInput.split('/').map(s => s.trim()).filter(Boolean);
            let targetNodes = [];
            let relatedNodes = new Set();
            let relatedLinks = new Set();
            let isJointSearch = false;
            let jointTarget = null;

            /* ========= è”åˆæœç´¢ ========= */
            if (mode === 'all') {
                if (names.length !== 2) {
                    alert("è”åˆæœç´¢å¿…é¡»è¾“å…¥ä¸¤ä¸ªäººåï¼Œç”¨ / åˆ†éš”");
                    return;
                }

                const [a, b] = names;
                targetNodes = currentData.nodes.filter(n => n.name === a || n.name === b);
                
                if (targetNodes.length < 2) {
                    alert("æœªæ‰¾åˆ°æŒ‡å®šçš„å½±äºº");
                    return;
                }
                
                relatedNodes.add(a);
                relatedNodes.add(b);
                
                // æŸ¥æ‰¾ä¸¤äººä¹‹é—´çš„ç›´æ¥åˆä½œå…³ç³»
                const directLinks = currentData.links.filter(l => 
                    (l.source === a && l.target === b) || (l.source === b && l.target === a)
                );
                
                if (directLinks.length === 0) {
                    alert("è¿™ä¸¤ä¸ªäººä¹‹é—´æ²¡æœ‰ç›´æ¥åˆä½œå…³ç³»");
                } else {
                    directLinks.forEach(l => {
                        relatedLinks.add(l.source + "-" + l.target);
                        relatedLinks.add(l.target + "-" + l.source);
                    });
                }
                
                isJointSearch = true;
            }

            /* ========= å¯¼æ¼”å•ç‹¬æœç´¢ ========= */
            else if (mode === 'director') {
                if (names.length !== 1) {
                    alert("å¯¼æ¼”æœç´¢åªèƒ½è¾“å…¥ä¸€ä¸ªå¯¼æ¼”åå­—");
                    return;
                }

                const name = names[0];
                const mainNode = currentData.nodes.find(
                    n => n.name === name && n.role === 'director'
                );

                if (!mainNode) {
                    alert("æœªæ‰¾åˆ°è¯¥å¯¼æ¼”");
                    return;
                }
                
                targetNodes = [mainNode];
                relatedNodes.add(name);
                
                // æŸ¥æ‰¾æ‰€æœ‰ä¸è¯¥å¯¼æ¼”ç›¸å…³çš„è¾¹
                currentData.links.forEach(l => {
                    if (l.source === name || l.target === name) {
                        relatedLinks.add(l.source + "-" + l.target);
                        relatedLinks.add(l.target + "-" + l.source);
                        relatedNodes.add(l.source);
                        relatedNodes.add(l.target);
                    }
                });
                
                jointTarget = name;
            }

            /* ========= æ¼”å‘˜å•ç‹¬æœç´¢ ========= */
            else if (mode === 'actor') {
                if (names.length !== 1) {
                    alert("æ¼”å‘˜æœç´¢åªèƒ½è¾“å…¥ä¸€ä¸ªæ¼”å‘˜åå­—");
                    return;
                }

                const name = names[0];
                const mainNode = currentData.nodes.find(
                    n => n.name === name && n.role === 'actor'
                );

                if (!mainNode) {
                    alert("æœªæ‰¾åˆ°è¯¥æ¼”å‘˜");
                    return;
                }
                
                targetNodes = [mainNode];
                relatedNodes.add(name);
                
                // æŸ¥æ‰¾æ‰€æœ‰ä¸è¯¥æ¼”å‘˜ç›¸å…³çš„è¾¹
                currentData.links.forEach(l => {
                    if (l.source === name || l.target === name) {
                        relatedLinks.add(l.source + "-" + l.target);
                        relatedLinks.add(l.target + "-" + l.source);
                        relatedNodes.add(l.source);
                        relatedNodes.add(l.target);
                    }
                });
                
                jointTarget = name;
            }

            /* ========= å¤„ç†æ‰€æœ‰èŠ‚ç‚¹å’Œè¾¹ ========= */
            const processedNodes = currentData.nodes.map(node => {
                const isRelated = relatedNodes.has(node.name);
                const isTarget = targetNodes.some(n => n.name === node.name);
                
                let symbolSize = Math.max(15, Math.min(50, (node.movieCount || 1) * 2));
                if (isTarget) {
                    symbolSize = Math.max(symbolSize * 1.8, 35); // æ”¾å¤§ç›®æ ‡èŠ‚ç‚¹
                }
                
                return {
                    ...node,
                    symbolSize: symbolSize,
                    itemStyle: {
                        color: getRoleColor(node.role),
                        opacity: isRelated ? 1 : 0.3, // ç›¸å…³èŠ‚ç‚¹å®Œå…¨ä¸é€æ˜ï¼Œå…¶ä»–èŠ‚ç‚¹åŠé€æ˜
                        borderWidth: isTarget ? 4 : (isRelated ? 2 : 1),
                        borderColor: isTarget ? '#ff0000' : '#333'
                    },
                    label: {
                        show: isRelated, // åªæ˜¾ç¤ºç›¸å…³èŠ‚ç‚¹çš„æ ‡ç­¾
                        fontSize: isTarget ? 14 : 10,
                        fontWeight: isTarget ? 'bold' : 'normal'
                    }
                };
            });
            
            const processedLinks = currentData.links.map(link => {
                const linkKey = link.source + "-" + link.target;
                const isRelated = relatedLinks.has(linkKey);
                
                return {
                    ...link,
                    lineStyle: {
                        color: isRelated ? (isJointSearch ? '#ff3333' : getRoleColor(currentData.nodes.find(n => n.name === link.source)?.role || 'other')) : '#ccc',
                        width: isRelated ? Math.max(3, link.value / 3) : 0.5,
                        opacity: isRelated ? 1 : 0.1,
                        type: isRelated ? 'solid' : 'dashed'
                    },
                    emphasis: {
                        lineStyle: {
                            width: isRelated ? Math.max(5, link.value / 2) : 1
                        }
                    }
                };
            });

            /* ========= æ›´æ–°å›¾è¡¨ ========= */
            chart.setOption({
                series: [{
                    data: processedNodes,
                    links: processedLinks,
                    zoom: 1,
                    center: ['50%', '50%']
                }]
            }, false);

            /* ========= è‡ªåŠ¨å±…ä¸­ + æ”¾å¤§ç›®æ ‡èŠ‚ç‚¹ ========= */
            if (jointTarget) {
                focusOnNode(jointTarget);
            } else if (targetNodes.length > 0) {
                focusOnNode(targetNodes[0].name);
            }
        }


        // è‡ªåŠ¨å±…ä¸­ + æ”¾å¤§èŠ‚ç‚¹
        function focusOnNode(name) {
            // å…ˆåº”ç”¨é«˜äº®æ•ˆæœ
            chart.dispatchAction({
                type: 'focusNodeAdjacency',
                seriesIndex: 0,
                name: name
            });
            
            // è·å–å›¾è¡¨å®ä¾‹
            const option = chart.getOption();
            const series = option.series[0];
            
            // æŸ¥æ‰¾ç›®æ ‡èŠ‚ç‚¹
            const targetNode = series.data.find(node => node.name === name);
            
            if (targetNode) {
                // è·å–å½“å‰å›¾è¡¨çš„è§†å›¾ä¿¡æ¯
                const dom = chart.getDom();
                const rect = dom.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;
                
                // ç¡®ä¿å›¾è¡¨å®¹å™¨åœ¨å¯è§åŒºåŸŸå†…
                dom.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center',
                    inline: 'center'
                });
                
                // é‡ç½®å›¾è¡¨çš„ä¸­å¿ƒå’Œç¼©æ”¾ï¼Œç¡®ä¿èŠ‚ç‚¹å¯è§
                chart.setOption({
                    series: [{
                        zoom: 1.2, // åˆå§‹ç¼©æ”¾ï¼Œç¡®ä¿å…³ç³»ç½‘ç»œå¯è§
                        center: ['50%', '50%'],
                        animationDurationUpdate: 800,
                        animationEasingUpdate: 'cubicOut'
                    }]
                }, false);
                
                // ç¡®ä¿å›¾è¡¨æ•°æ®å·²æ›´æ–°
                chart.resize();
                
                // ä½¿ç”¨æ›´ç²¾ç¡®çš„æ–¹æ³•ç¡®ä¿èŠ‚ç‚¹å±…ä¸­
                setTimeout(() => {
                    // è·å–èŠ‚ç‚¹åœ¨ç”»å¸ƒä¸Šçš„ä½ç½®
                    const pos = chart.convertToPixel({
                        seriesIndex: 0
                    }, [targetNode.x || 0, targetNode.y || 0]);
                    
                    if (pos && pos.length === 2) {
                        // è®¡ç®—éœ€è¦è°ƒæ•´çš„åç§»é‡
                        const offsetX = (width / 2 - pos[0]) / chart.getOption().series[0].zoom;
                        const offsetY = (height / 2 - pos[1]) / chart.getOption().series[0].zoom;
                        
                        // è®¡ç®—æ–°çš„ä¸­å¿ƒä½ç½®
                        const currentCenter = chart.getOption().series[0].center;
                        const newCenterX = parseFloat(currentCenter[0]) + (offsetX / width) * 100;
                        const newCenterY = parseFloat(currentCenter[1]) + (offsetY / height) * 100;
                        
                        // åº”ç”¨æ–°çš„ä¸­å¿ƒä½ç½®å’Œé€‚å½“çš„ç¼©æ”¾
                        chart.setOption({
                            series: [{
                                center: [`${newCenterX}%`, `${newCenterY}%`],
                                zoom: 1.8, // æ”¾å¤§ä»¥æ¸…æ™°æ˜¾ç¤ºå…³ç³»ç½‘ç»œ
                                animationDurationUpdate: 600,
                                animationEasingUpdate: 'cubicOut'
                            }]
                        }, false);
                    }
                }, 400);
                
                // æœ€ç»ˆç¡®è®¤å±…ä¸­
                setTimeout(() => {
                    const pos = chart.convertToPixel({
                        seriesIndex: 0
                    }, [targetNode.x || 0, targetNode.y || 0]);
                    
                    if (pos && pos.length === 2) {
                        const offsetX = (width / 2 - pos[0]) / chart.getOption().series[0].zoom;
                        const offsetY = (height / 2 - pos[1]) / chart.getOption().series[0].zoom;
                        
                        if (Math.abs(offsetX) > 10 || Math.abs(offsetY) > 10) {
                            const currentCenter = chart.getOption().series[0].center;
                            const newCenterX = parseFloat(currentCenter[0]) + (offsetX / width) * 100;
                            const newCenterY = parseFloat(currentCenter[1]) + (offsetY / height) * 100;
                            
                            chart.setOption({
                                series: [{
                                    center: [`${newCenterX}%`, `${newCenterY}%`],
                                    animationDurationUpdate: 300
                                }]
                            }, false);
                        }
                    }
                }, 1200);
            } else {
                // å¦‚æœæ‰¾ä¸åˆ°èŠ‚ç‚¹ï¼Œè®¾ç½®é»˜è®¤çš„ä¸­å¿ƒå’Œç¼©æ”¾
                chart.setOption({
                    series: [{
                        zoom: 1.5,
                        center: ['50%', '50%'],
                        animationDurationUpdate: 800
                    }]
                }, false);
            }
        }

        // é‡ç½®å›¾è¡¨æ˜¾ç¤º
        function resetGraph() {
            chart.setOption({
                series: [{ data: currentData.nodes, links: currentData.links, zoom: 1, center: ['50%', '50%'] }]
            }, false);
        }

        // åŠ è½½ç½‘ç»œæ•°æ®
        function loadNetworkData() {
            console.log('å¼€å§‹åŠ è½½æ•°æ®...');
            fetch('data/full_network_data.json')
                .then(response => {
                    console.log('æ•°æ®åŠ è½½å“åº”:', response);
                    if (!response.ok) {
                        throw new Error('HTTP error! status: ' + response.status);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('æ•°æ®è§£ææˆåŠŸ:', data);
                    console.log('èŠ‚ç‚¹æ•°é‡:', data.nodes.length);
                    console.log('è¾¹æ•°é‡:', data.links.length);
                    originalData = data;
                    currentData = JSON.parse(JSON.stringify(data)); // æ·±æ‹·è´

                    // ç›´æ¥æ˜¾ç¤ºæ•°æ®
                    showNetworkData(data);
                    updateStatistics(data);
                })
                .catch(error => {
                    console.error('åŠ è½½æ•°æ®å¤±è´¥:', error);
                    alert('æ•°æ®åŠ è½½å¤±è´¥: ' + error.message);
                });
        }

        // ç›´æ¥æ˜¾ç¤ºç½‘ç»œæ•°æ®
        function showNetworkData(data) {
            console.log('å¼€å§‹æ˜¾ç¤ºç½‘ç»œæ•°æ®...');
            if (!chart) {
                console.error('å›¾è¡¨æœªåˆå§‹åŒ–');
                return;
            }

            // è®¡ç®—èŠ‚ç‚¹åº¦
            const nodeDegrees = {};
            data.links.forEach(link => {
                nodeDegrees[link.source] = (nodeDegrees[link.source] || 0) + 1;
                nodeDegrees[link.target] = (nodeDegrees[link.target] || 0) + 1;
            });
            console.log('èŠ‚ç‚¹åº¦è®¡ç®—å®Œæˆ:', nodeDegrees);

            console.log('å‡†å¤‡å›¾è¡¨é…ç½®...');
            // é…ç½®å›¾è¡¨
            const option = {
                title: {
                    text: 'å½±äººåˆä½œç½‘ç»œ',
                    subtext: `å…± ${data.nodes.length} ä¸ªèŠ‚ç‚¹, ${data.links.length} æ¡å…³ç³»`,
                    left: 'center',
                    textStyle: {
                        fontSize: 20,
                        fontWeight: 'bold'
                    }
                },
                tooltip: {
                    trigger: 'item',
                    formatter: function (params) {
                        if (params.dataType === 'node') {
                            return `
                                <div class="tooltip-content">
                                    <strong>${params.data.name}</strong><br/>
                                    ç±»å‹: ${params.data.role || 'æœªçŸ¥'}<br/>
                                    å‚ä¸ç”µå½±: ${params.data.movieCount || 0}éƒ¨<br/>
                                    å¹³å‡è¯„åˆ†: ${params.data.avgRating ? params.data.avgRating.toFixed(1) : 'N/A'}
                                </div>
                            `;
                        } else {
                            let moviesInfo = '';
                            if (params.data.topMovies && params.data.topMovies.length > 0) {
                                moviesInfo = '<br/><br/>åˆä½œç”µå½±:';
                                params.data.topMovies.forEach((movie, index) => {
                                    if (index < 3) { // åªæ˜¾ç¤ºå‰3éƒ¨ç”µå½±
                                        moviesInfo += `<br/>${movie.movie_name} (${movie.year}) - ${movie.rating || 'N/A'}`;
                                    }
                                });
                            }
                            return `
                                <div class="tooltip-content">
                                    <strong>${params.data.source} â†” ${params.data.target}</strong><br/>
                                    åˆä½œæ¬¡æ•°: ${params.data.value || 1}æ¬¡<br/>
                                    å¹³å‡è¯„åˆ†: ${params.data.avgRating ? params.data.avgRating.toFixed(1) : 'N/A'}
                                    ${moviesInfo}
                                </div>
                            `;
                        }
                    }
                },
                series: [{
                    type: 'graph',
                    layout: 'force',
                    force: {
                        repulsion: 300,  // å¢åŠ æ’æ–¥åŠ›ï¼Œé¿å…èŠ‚ç‚¹é‡å 
                        edgeLength: 120,  // å¢åŠ è¾¹é•¿åº¦
                        gravity: 0.1,     // å‡å°é‡åŠ›
                        friction: 0.6     // å¢åŠ æ‘©æ“¦åŠ›
                    },
                    roam: true,
                    data: data.nodes.map(node => ({
                        id: node.id,
                        name: node.name,
                        symbolSize: Math.max(15, Math.min(50, (nodeDegrees[node.id] || 1) * 2)),  // å¢å¤§èŠ‚ç‚¹å¤§å°
                        itemStyle: {
                            color: getRoleColor(node.role),
                            opacity: 0.8,  // ç¡®ä¿èŠ‚ç‚¹ä¸é€æ˜
                            borderColor: '#333',
                            borderWidth: 1
                        },
                        role: node.role,
                        movieCount: node.movieCount,
                        avgRating: node.avgRating
                    })),
                    links: data.links.map(link => ({
                        ...link,
                        lineStyle: {
                            color: '#666',
                            width: Math.max(1, Math.min(3, link.value / 5)),
                            opacity: 0.7
                        }
                    })),
                    label: {
                        show: true,
                        fontSize: 10,
                        formatter: '{b}',
                        backgroundColor: 'rgba(255, 255, 255, 0.8)',
                        padding: [2, 5]
                    },
                    emphasis: {
                        focus: 'adjacency',
                        itemStyle: {
                            borderWidth: 2,
                            shadowBlur: 10,
                            shadowColor: 'rgba(0, 0, 0, 0.5)'
                        }
                    }
                }]
            };

            console.log('å›¾è¡¨é…ç½®å®Œæˆï¼Œå¼€å§‹è®¾ç½®é€‰é¡¹...');
            // åº”ç”¨é…ç½®
            chart.setOption(option);
            console.log('å›¾è¡¨è®¾ç½®å®Œæˆ');
        }

        // æ ¹æ®è§’è‰²è·å–é¢œè‰²
        function getRoleColor(role) {
            const colors = {
                'director': '#ff6b6b',
                'actor': '#4ecdc4',
                'writer': '#45b7d1',
                'other': '#96ceb4'
            };
            return colors[role] || colors['other'];
        }

        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        function updateStatistics(data) {
            const stats = calculateStatistics(data);

            document.getElementById('networkStats').innerHTML = `
                <div class="stat-item ${stats.totalNodes > 100 ? 'highlight' : ''}">
                    <span>æ€»èŠ‚ç‚¹æ•°:</span>
                    <span>${stats.totalNodes}</span>
                </div>
                <div class="stat-item ${stats.totalLinks > 200 ? 'highlight' : ''}">
                    <span>æ€»è¾¹æ•°:</span>
                    <span>${stats.totalLinks}</span>
                </div>
                <div class="stat-item">
                    <span>ç½‘ç»œå¯†åº¦:</span>
                    <span>${stats.density.toFixed(4)}</span>
                </div>
                <div class="stat-item">
                    <span>å¹³å‡åº¦:</span>
                    <span>${stats.avgDegree.toFixed(2)}</span>
                </div>
                <div class="stat-item ${stats.maxDegree > 10 ? 'highlight' : ''}">
                    <span>æœ€å¤§åº¦:</span>
                    <span>${stats.maxDegree}</span>
                </div>
                <div class="stat-item">
                    <span>å¹³å‡è¯„åˆ†:</span>
                    <span>${stats.avgRating.toFixed(2)}</span>
                </div>
            `;

            document.getElementById('keyInsights').innerHTML = `
                <div style="color: #e74c3c; margin-bottom: 8px;">
                    ${stats.insights.highCoop ? 'ğŸ”´ ' + stats.insights.highCoop : ''}
                </div>
                <div style="color: #f39c12; margin-bottom: 8px;">
                    ${stats.insights.lowRating ? 'ğŸŸ¡ ' + stats.insights.lowRating : ''}
                </div>
                <div style="color: #27ae60;">
                    ${stats.insights.centralNode ? 'ğŸŸ¢ ' + stats.insights.centralNode : ''}
                </div>
            `;
        }

        // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
        function calculateStatistics(data) {
            const totalNodes = data.nodes.length;
            const totalLinks = data.links.length;

            // è®¡ç®—åº¦åˆ†å¸ƒ
            const nodeMap = new Map();
            data.nodes.forEach(node => nodeMap.set(node.id, { degree: 0 }));

            data.links.forEach(link => {
                if (nodeMap.has(link.source)) nodeMap.get(link.source).degree++;
                if (nodeMap.has(link.target)) nodeMap.get(link.target).degree++;
            });

            const degrees = Array.from(nodeMap.values()).map(n => n.degree);
            const avgDegree = degrees.reduce((a, b) => a + b, 0) / totalNodes;
            const maxDegree = Math.max(...degrees);

            // è®¡ç®—ç½‘ç»œå¯†åº¦ï¼ˆæ— å‘å›¾ï¼‰
            const maxPossibleLinks = totalNodes * (totalNodes - 1) / 2;
            const density = totalLinks / maxPossibleLinks;

            // è®¡ç®—å¹³å‡è¯„åˆ†
            const ratings = data.links.map(link => link.avgRating).filter(r => r);
            const avgRating = ratings.length ? ratings.reduce((a, b) => a + b, 0) / ratings.length : 0;

            // ç”Ÿæˆæ´å¯Ÿ
            const insights = {
                highCoop: totalLinks > 150 ? 'æ£€æµ‹åˆ°å¤§é‡é«˜é¢‘åˆä½œå…³ç³»' : '',
                lowRating: avgRating < 6 ? 'å­˜åœ¨ä½åˆ†ç”µå½±åˆä½œæ¨¡å¼' : '',
                centralNode: maxDegree > 15 ? `æ ¸å¿ƒå½±äººåº¦ä¸­å¿ƒæ€§: ${maxDegree}` : ''
            };

            return { totalNodes, totalLinks, density, avgDegree, maxDegree, avgRating, insights };
        }

        // åº”ç”¨ç­›é€‰æ¡ä»¶
        function applyFilters() {
            if (!currentData) return;

            const minCoop = parseInt(document.getElementById('minCoop').value) || 1;
            const maxRating = parseFloat(document.getElementById('maxRating').value) || 10;

            // è¿‡æ»¤æ•°æ®
            const filteredLinks = currentData.links.filter(link => {
                return link.value >= minCoop && link.avgRating <= maxRating;
            });

            // è·å–æ‰€æœ‰æ¶‰åŠçš„èŠ‚ç‚¹ID
            const nodeIds = new Set();
            filteredLinks.forEach(link => {
                nodeIds.add(link.source);
                nodeIds.add(link.target);
            });

            const filteredNodes = currentData.nodes.filter(node => nodeIds.has(node.id));

            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            const filteredData = { nodes: filteredNodes, links: filteredLinks };
            updateStatistics(filteredData);

            // æ˜¾ç¤ºè¿‡æ»¤åçš„æ•°æ®
            showNetworkData(filteredData);
        }

        // æ·»åŠ å¸ƒå±€ç®—æ³•åˆ‡æ¢åŠŸèƒ½
        document.getElementById('layoutSelect').addEventListener('change', function() {
            if (chart) {
                const layout = this.value;
                chart.setOption({
                    series: [{
                        layout: layout
                    }]
                });
            }
        });

        // é‡ç½®ç­›é€‰æ¡ä»¶
        function resetFilters() {
            document.getElementById('minCoop').value = 1;
            document.getElementById('maxRating').value = 10;
            document.getElementById('nodeSize').value = 20;
            document.getElementById('layoutSelect').value = 'force';

            applyFilters();
        }

        // å¯¼å‡ºå›¾ç‰‡
        function exportImage() {
            if (chart) {
                const url = chart.getDataURL({
                    type: 'png',
                    pixelRatio: 2,
                    backgroundColor: '#fff'
                });

                const link = document.createElement('a');
                link.href = url;
                link.download = `å½±äººåˆä½œç½‘ç»œ_${new Date().toISOString().split('T')[0]}.png`;
                link.click();
            }
        }
        // ===== æ–°å¢ï¼šæ–°ç”µå½±è¯„åˆ†é¢„æµ‹ï¼ˆç‹¬ç«‹æ¨¡å—ï¼Œä¸å½±å“åŸæœ‰ JSï¼‰=====
        function predictMovie() {
            const directors = document.getElementById("directorsInput")
                .value.split("/")
                .map(s => s.trim())
                .filter(Boolean);

            const actors = document.getElementById("actorsInput")
                .value.split("/")
                .map(s => s.trim())
                .filter(Boolean);

            const wRelation = parseFloat(
                document.getElementById("relationWeight").value
            );

            const weights = {
                actor: (1 - wRelation) / 2,
                director: (1 - wRelation) / 2,
                relation: wRelation
            };

            document.getElementById("predictResult").innerText = "â³ æ­£åœ¨é¢„æµ‹ä¸­...";

            fetch("http://127.0.0.1:5000/predict", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    directors,
                    actors,
                    weights
                })
            })
            .then(res => res.json())
            .then(data => {
                document.getElementById("predictResult").innerHTML =
                    `â­ é¢„æµ‹è¯„åˆ†ï¼š<b>${data.final_score}</b><br>
                     æ¼”å‘˜è¯„åˆ†ï¼š${data.actor_score}<br>
                     å¯¼æ¼”è¯„åˆ†ï¼š${data.director_score}<br>
                     å…³ç³»è¯„åˆ†ï¼š${data.relation_score}`;
            })
            .catch(() => {
                document.getElementById("predictResult").innerText =
                    "âŒ è¯·æ±‚å¤±è´¥ï¼ˆè¯·æ£€æŸ¥åç«¯ï¼‰";
           });
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', initChart);
    </script>
</body>
</html>