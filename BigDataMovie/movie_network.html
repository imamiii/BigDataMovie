<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å½±äººåˆä½œç½‘ç»œå¯è§†åŒ–</title>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.2/dist/echarts.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Microsoft YaHei', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      overflow: hidden;
    }
    .header {
      background: linear-gradient(90deg, #2c3e50, #3498db);
      color: white;
      padding: 20px;
      text-align: center;
    }
    .header h1 { font-size: 2.2em; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3); }
    .header p { font-size: 1.1em; opacity: 0.9; }
    .controls {
      background: #f8f9fa;
      padding: 15px 20px;
      border-bottom: 1px solid #e9ecef;
      display: flex;
      gap: 15px;
      align-items: center;
      flex-wrap: wrap;
    }
    .control-group { display: flex; align-items: center; gap: 8px; }
    .control-group label { font-weight: bold; color: #495057; }
    select, input, button {
      padding: 8px 12px;
      border: 1px solid #ced4da;
      border-radius: 5px;
      font-size: 14px;
    }
    button {
      background: #007bff;
      color: white;
      border: none;
      cursor: pointer;
      transition: background 0.3s;
    }
    button:hover { background: #0056b3; }
    .chart-container { display: flex; height: 700px; }
    #mainChart { flex: 3; height: 100%; }
    .sidebar {
      flex: 1;
      background: #f8f9fa;
      border-left: 1px solid #e9ecef;
      padding: 20px;
      overflow-y: auto;
      max-height: 700px;
    }
    .stats-panel {
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
    }
    .stats-panel h3 {
      color: #2c3e50;
      margin-bottom: 10px;
      border-bottom: 2px solid #3498db;
      padding-bottom: 5px;
    }
    .stat-item {
      display: flex;
      justify-content: space-between;
      margin: 8px 0;
      padding: 5px;
      background: #f8f9fa;
      border-radius: 4px;
    }
    .highlight { background: #e3f2fd !important; font-weight: bold; }
    .tooltip-content { max-width: 320px; }
    .loading {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 200px;
      font-size: 1.2em;
      color: #666;
    }
    .legend { display: flex; gap: 15px; margin-top: 10px; flex-wrap: wrap; }
    .legend-item { display: flex; align-items: center; gap: 5px; }
    .legend-color { width: 15px; height: 15px; border-radius: 50%; }
    .footer {
      text-align: center;
      padding: 15px;
      background: #f8f9fa;
      color: #6c757d;
      border-top: 1px solid #e9ecef;
    }
  </style>
</head>

<body>
<div class="container">
  <div class="header">
    <h1>ğŸ¬ å½±äººåˆä½œç½‘ç»œåˆ†æç³»ç»Ÿ</h1>
    <p>åŸºäºè±†ç“£ç”µå½±æ•°æ®çš„å½±äººåˆä½œå…³ç³»å¯è§†åŒ–åˆ†æ</p>
  </div>

  <div class="controls">
    <div class="control-group">
      <label for="layoutSelect">å¸ƒå±€ç®—æ³•ï¼š</label>
      <select id="layoutSelect">
        <option value="force">åŠ›å¯¼å‘å¸ƒå±€</option>
        <option value="circular">ç¯å½¢å¸ƒå±€</option>
        <option value="none">å›ºå®šä½ç½®</option>
      </select>
    </div>

    <div class="control-group">
      <label for="minCoop">æœ€å°åˆä½œæ¬¡æ•°ï¼š</label>
      <input type="number" id="minCoop" min="1" max="20" value="1">
    </div>

    <!-- âœ… è¯„åˆ†åŒºé—´ -->
    <div class="control-group">
      <label for="minRating">æœ€ä½è¯„åˆ†ï¼š</label>
      <input type="number" id="minRating" min="0" max="10" value="0" step="0.1">
    </div>
    <div class="control-group">
      <label for="maxRating">æœ€é«˜è¯„åˆ†ï¼š</label>
      <input type="number" id="maxRating" min="0" max="10" value="10" step="0.1">
    </div>

    <button onclick="applyFilters()">åº”ç”¨ç­›é€‰</button>
    <button onclick="resetFilters()">é‡ç½®</button>
    <button onclick="exportImage()">å¯¼å‡ºå›¾ç‰‡</button>

    <!-- âœ… ç±»å‹ç­›é€‰ï¼ˆå¤šé€‰ï¼‰ -->
    <div class="control-group">
      <label for="typeSelect">ç”µå½±ç±»å‹ï¼š</label>
      <select id="typeSelect" multiple size="1" style="min-width:180px;">
        <!-- è¿è¡Œæ—¶åŠ¨æ€å¡«å…… -->
      </select>
    </div>

    <div class="control-group">
      <label for="searchInput">æœç´¢å½±äººï¼š</label>
      <input type="text" id="searchInput" placeholder="è¾“å…¥å§“åï¼ˆå¯ç”¨ / åˆ†éš”ï¼‰">
      <select id="roleFilter">
        <option value="all">ä¸¤äººè”åˆï¼ˆA/Bï¼‰</option>
        <option value="actor">åªæœç´¢æ¼”å‘˜</option>
        <option value="director">åªæœç´¢å¯¼æ¼”</option>
      </select>
      <button onclick="searchPerson()">æœç´¢</button>
      <button onclick="resetGraph()">é‡ç½®å›¾</button>
    </div>
  </div>

  <div class="chart-container">
    <div id="mainChart"></div>

    <div class="sidebar">
      <div class="stats-panel">
        <h3>ğŸ“Š ç½‘ç»œç»Ÿè®¡</h3>
        <div id="networkStats" class="loading">åŠ è½½ä¸­...</div>
      </div>

      <div class="stats-panel">
        <h3>ğŸ¯ å…³é”®å‘ç°</h3>
        <div id="keyInsights" class="loading">åŠ è½½ä¸­...</div>
      </div>

      <div class="stats-panel">
        <h3>ğŸ¨ å›¾ä¾‹è¯´æ˜</h3>
        <div class="legend">
          <div class="legend-item"><div class="legend-color" style="background-color:#ff6b6b;"></div><span>å¯¼æ¼”</span></div>
          <div class="legend-item"><div class="legend-color" style="background-color:#4ecdc4;"></div><span>æ¼”å‘˜</span></div>
          <div class="legend-item"><div class="legend-color" style="background-color:#45b7d1;"></div><span>ç¼–å‰§</span></div>
          <div class="legend-item"><div class="legend-color" style="background-color:#96ceb4;"></div><span>å…¶ä»–</span></div>
        </div>
      </div>

      <!-- è¯„åˆ†é¢„æµ‹æ¨¡å—ï¼šä¿æŒä¸åŠ¨ -->
      <div class="stats-panel">
        <h3>ğŸ¬ æ–°ç”µå½±è¯„åˆ†é¢„æµ‹</h3>
        <label>å¯¼æ¼”ï¼ˆç”¨ / åˆ†éš”ï¼‰</label>
        <input id="directorsInput" placeholder="å¼ è‰ºè°‹/é™ˆå‡¯æ­Œ" style="width:100%;margin-bottom:8px;">
        <label>æ¼”å‘˜ï¼ˆç”¨ / åˆ†éš”ï¼‰</label>
        <input id="actorsInput" placeholder="å·©ä¿/è‘›ä¼˜" style="width:100%;margin-bottom:8px;">
        <label>å…³ç³»æƒé‡</label>
        <input type="range" id="relationWeight" min="0" max="1" step="0.1" value="0.2" style="width:100%;">
        <button style="margin-top:10px;width:100%;" onclick="predictMovie()">é¢„æµ‹è¯„åˆ†</button>
        <div id="predictResult" style="margin-top:10px;font-size:14px;"></div>
      </div>
    </div>
  </div>

  <div class="footer">
    <p>æ•°æ®æ¥æºï¼šè±†ç“£ç”µå½± | å¯è§†åŒ–æŠ€æœ¯ï¼šECharts | ç”Ÿæˆæ—¶é—´ï¼š<span id="currentTime"></span></p>
  </div>
</div>

<script>
  let chart = null;
  let originalData = null; // å…¨é‡åŸå§‹æ•°æ®ï¼ˆä¸æ”¹ï¼‰
  let currentData = null;  // å½“å‰ç­›é€‰åæ•°æ®ï¼ˆä¼šå˜ï¼‰

  function initChart() {
    chart = echarts.init(document.getElementById('mainChart'));
    loadNetworkData();

    window.addEventListener('resize', function () {
      chart.resize();
    });

    document.getElementById('currentTime').textContent = new Date().toLocaleString();
  }

  function loadNetworkData() {
    fetch('data/full_network_data.json')
      .then(res => {
        if (!res.ok) throw new Error('HTTP error! status: ' + res.status);
        return res.json();
      })
      .then(data => {
        originalData = data;
        initTypeOptions();
        // é»˜è®¤å…ˆæŒ‰å½“å‰æ§ä»¶è¿‡æ»¤ä¸€æ¬¡ï¼ˆ=å…¨é‡ï¼‰
        currentData = buildFilteredData();
        showNetworkData(currentData);
        updateStatistics(currentData);
      })
      .catch(err => {
        console.error(err);
        alert('æ•°æ®åŠ è½½å¤±è´¥: ' + err.message);
      });
  }

  function normalizeTypesJS(t) {
    if (!t) return [];
    if (Array.isArray(t)) return t.map(x => String(x).trim()).filter(Boolean);

    let s = String(t).trim();
    if (!s || s === 'æœªçŸ¥' || s === 'nan') return [];
    ['ã€', ',', 'ï¼Œ', '|'].forEach(sep => s = s.split(sep).join('/'));
    return s.split('/').map(x => x.trim()).filter(Boolean);
  }

  function initTypeOptions() {
    const sel = document.getElementById('typeSelect');
    if (!sel || !originalData) return;

    const set = new Set();
    for (const link of originalData.links || []) {
      const movies = Array.isArray(link.movies) ? link.movies : [];
      for (const m of movies) {
        const ts = normalizeTypesJS(m && m.types);
        ts.forEach(x => set.add(x));
      }
    }

    const types = Array.from(set).sort((a, b) => a.localeCompare(b, 'zh-Hans-CN'));

    sel.innerHTML = '';
    // ä¸é€‰ä»»ä½•ç±»å‹ = ä¸æŒ‰ç±»å‹ç­›ï¼ˆå…¨é€‰æ•ˆæœï¼‰
    types.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t;
      opt.textContent = t;
      sel.appendChild(opt);
    });

    // ç±»å‹å˜åŒ–ä¹Ÿè‡ªåŠ¨åº”ç”¨ç­›é€‰
    sel.addEventListener('change', applyFilters);
  }


  // âœ… è¿‡æ»¤é€»è¾‘ï¼šåŸºäºæ¯æ¡è¾¹çš„ movies åˆ—è¡¨
  function buildFilteredData() {
    if (!originalData) return {nodes: [], links: []};

    const minCoop = parseInt(document.getElementById('minCoop').value) || 1;
    let minRating = parseFloat(document.getElementById('minRating').value);
    let maxRating = parseFloat(document.getElementById('maxRating').value);

    if (isNaN(minRating)) minRating = 0;
    if (isNaN(maxRating)) maxRating = 10;
    if (minRating > maxRating) {
      const t = minRating; minRating = maxRating; maxRating = t;
    }

    const typeSelect = document.getElementById('typeSelect');
    const selectedTypes = typeSelect
      ? Array.from(typeSelect.selectedOptions).map(o => o.value).filter(Boolean)
      : [];
    const selectedTypeSet = new Set(selectedTypes);
    const useTypeFilter = selectedTypeSet.size > 0;

    const filteredLinks = [];

    for (const link of originalData.links) {
      const movies = Array.isArray(link.movies) ? link.movies : [];
      // è¿‡æ»¤åŒºé—´å†…ç”µå½±ï¼ˆæŒ‰è¯„åˆ†å’Œç±»å‹ï¼‰
      const inRange = movies.filter(m => {
        const r = m && m.rating;
        if (r === null || r === undefined) return false;
        const rr = parseFloat(r);
        if (isNaN(rr)) return false;

        // è¯„åˆ†æ¡ä»¶
        if (!(rr >= minRating && rr <= maxRating)) return false;

        // ç±»å‹æ¡ä»¶ï¼šé€‰äº†ç±»å‹æ‰è¿‡æ»¤ï¼›å¤šé€‰ = å‘½ä¸­ä»»æ„ä¸€ä¸ªå³å¯
        if (useTypeFilter) {
          const ts = normalizeTypesJS(m && m.types);
          return ts.some(t => selectedTypeSet.has(t));
        }
        return true;
      });


      const coopInRange = inRange.length;
      if (coopInRange < minCoop) continue;

      // ä»…ç”¨äºæ˜¾ç¤ºçš„ avgRatingï¼šåŒºé—´å†…ç”µå½±å‡å€¼ï¼ˆä¸å‚ä¸ç­›é€‰ï¼‰
      const avg = coopInRange
        ? inRange.reduce((s, m) => s + parseFloat(m.rating), 0) / coopInRange
        : null;

      const topMovies = [...inRange].sort((a, b) => (b.rating ?? -1) - (a.rating ?? -1)).slice(0, 5);

      filteredLinks.push({
        ...link,
        value: coopInRange,     // âœ… åˆä½œæ¬¡æ•° = åŒºé—´å†…ç”µå½±æ•°
        movies: inRange,        // âœ… åªä¿ç•™åŒºé—´å†…ç”µå½±
        avgRating: avg,
        topMovies: topMovies
      });
    }

    const nodeIds = new Set();
    filteredLinks.forEach(l => { nodeIds.add(l.source); nodeIds.add(l.target); });

    const filteredNodes = originalData.nodes.filter(n => nodeIds.has(n.id || n.name));

    return { nodes: filteredNodes, links: filteredLinks };
  }

  function applyFilters() {
    if (!originalData) return;
    currentData = buildFilteredData();
    showNetworkData(currentData);
    updateStatistics(currentData);
  }

  function resetFilters() {
    document.getElementById('minCoop').value = 1;
    document.getElementById('minRating').value = 0;
    document.getElementById('maxRating').value = 10;
    const sel = document.getElementById('typeSelect');
    if (sel) Array.from(sel.options).forEach(o => o.selected = false);
    applyFilters();
  }

  function resetGraph() {
    // é‡ç½®åˆ°â€œå½“å‰ç­›é€‰ç»“æœâ€ï¼ˆä¸æ˜¯å…¨é‡ï¼‰
    showNetworkData(currentData);
    updateStatistics(currentData);
  }

  // ====== æœç´¢å½±äººï¼šå…ˆæŒ‰åŒºé—´åˆ·æ–° currentDataï¼Œå†åšé«˜äº®/èšç„¦ ======
  function searchPerson() {
    const rawInput = document.getElementById('searchInput').value.trim();
    const mode = document.getElementById('roleFilter').value;
    if (!rawInput) return;

    // å…ˆç¡®ä¿ currentData = å½“å‰åŒºé—´ç­›é€‰ç»“æœ
    currentData = buildFilteredData();
    showNetworkData(currentData);
    updateStatistics(currentData);

    const names = rawInput.split('/').map(s => s.trim()).filter(Boolean);

    let targetNodes = [];
    let relatedNodes = new Set();
    let relatedLinks = new Set();
    let isJointSearch = false;
    let jointTarget = null;

    if (mode === 'all') {
      if (names.length !== 2) {
        alert("è”åˆæœç´¢å¿…é¡»è¾“å…¥ä¸¤ä¸ªäººåï¼Œç”¨ / åˆ†éš”");
        return;
      }
      const [a, b] = names;
      targetNodes = currentData.nodes.filter(n => n.name === a || n.name === b);
      if (targetNodes.length < 2) {
        alert("æœªæ‰¾åˆ°æŒ‡å®šçš„å½±äººï¼ˆæ³¨æ„ï¼šåªåœ¨å½“å‰è¯„åˆ†åŒºé—´å†…æŸ¥æ‰¾ï¼‰");
        return;
      }
      relatedNodes.add(a); relatedNodes.add(b);

      const directLinks = currentData.links.filter(l =>
        (l.source === a && l.target === b) || (l.source === b && l.target === a)
      );
      if (directLinks.length === 0) {
        alert("è¿™ä¸¤ä¸ªäººåœ¨å½“å‰è¯„åˆ†åŒºé—´å†…æ²¡æœ‰ç›´æ¥åˆä½œå…³ç³»");
      } else {
        directLinks.forEach(l => {
          relatedLinks.add(l.source + "-" + l.target);
          relatedLinks.add(l.target + "-" + l.source);
        });
      }
      isJointSearch = true;

    } else if (mode === 'director') {
      if (names.length !== 1) {
        alert("å¯¼æ¼”æœç´¢åªèƒ½è¾“å…¥ä¸€ä¸ªåå­—");
        return;
      }
      const name = names[0];
      const mainNode = currentData.nodes.find(n => {
        if (n.name !== name) return false;
        const roles = Array.isArray(n.roles) ? n.roles : [];
        return roles.includes('director') || n.role === 'director'; // å…¼å®¹æ—§å­—æ®µ
      });

      if (!mainNode) {
        alert("æœªæ‰¾åˆ°è¯¥å¯¼æ¼”ï¼ˆæ³¨æ„ï¼šåªåœ¨å½“å‰è¯„åˆ†åŒºé—´å†…æŸ¥æ‰¾ï¼‰");
        return;
      }
      targetNodes = [mainNode];
      relatedNodes.add(name);

      currentData.links.forEach(l => {
        if (l.source === name || l.target === name) {
          relatedLinks.add(l.source + "-" + l.target);
          relatedLinks.add(l.target + "-" + l.source);
          relatedNodes.add(l.source);
          relatedNodes.add(l.target);
        }
      });
      jointTarget = name;

    } else if (mode === 'actor') {
      if (names.length !== 1) {
        alert("æ¼”å‘˜æœç´¢åªèƒ½è¾“å…¥ä¸€ä¸ªåå­—");
        return;
      }
      const name = names[0];
      const mainNode = currentData.nodes.find(n => {
        if (n.name !== name) return false;
        const roles = Array.isArray(n.roles) ? n.roles : [];
        return roles.includes('actor') || n.role === 'actor';
      });

      if (!mainNode) {
        alert("æœªæ‰¾åˆ°è¯¥æ¼”å‘˜ï¼ˆæ³¨æ„ï¼šåªåœ¨å½“å‰è¯„åˆ†åŒºé—´å†…æŸ¥æ‰¾ï¼‰");
        return;
      }
      targetNodes = [mainNode];
      relatedNodes.add(name);

      currentData.links.forEach(l => {
        if (l.source === name || l.target === name) {
          relatedLinks.add(l.source + "-" + l.target);
          relatedLinks.add(l.target + "-" + l.source);
          relatedNodes.add(l.source);
          relatedNodes.add(l.target);
        }
      });
      jointTarget = name;
    }

        // âœ… åªä¿ç•™â€œç›¸å…³å­å›¾â€ï¼šæ— å…³ç½‘ç»œç›´æ¥ä¸æ¸²æŸ“
    const subNodes = currentData.nodes.filter(n => relatedNodes.has(n.name));
    const subLinks = currentData.links.filter(l => {
      const k = l.source + "-" + l.target;
      return relatedLinks.has(k);
    });

    const processedNodes = subNodes.map(node => {
      const isTarget = targetNodes.some(n => n.name === node.name);

      let symbolSize = Math.max(15, Math.min(55, (node.movieCount || 1) * 2));
      if (isTarget) symbolSize = Math.max(symbolSize * 1.8, 38);

      return {
        ...node,
        symbolSize,
        itemStyle: {
          color: getRoleColor(node.role),
          opacity: 1,                 // âœ… éƒ½æ˜¯ç›¸å…³èŠ‚ç‚¹ï¼Œç›´æ¥å…¨æ˜¾ç¤º
          borderWidth: isTarget ? 4 : 2,
          borderColor: isTarget ? '#ff0000' : '#333'
        },
        label: {
          show: true,                 // âœ… ç›¸å…³å­å›¾å†…å…¨éƒ¨æ˜¾ç¤ºæ ‡ç­¾
          fontSize: isTarget ? 14 : 10,
          fontWeight: isTarget ? 'bold' : 'normal'
        }
      };
    });

    const processedLinks = subLinks.map(link => {
      return {
        ...link,
        lineStyle: {
          color: (isJointSearch ? '#ff3333' : '#666'),
          width: Math.max(3, (link.value || 1)),
          opacity: 1,
          type: 'solid'
        }
      };
    });

    // âœ… ç”¨â€œå­å›¾æ•°æ®â€ç›´æ¥åˆ·æ–°å›¾ï¼ˆæ— å…³ç½‘ç»œæ¶ˆå¤±ï¼‰
    chart.setOption({
      series: [{
        data: processedNodes,
        links: processedLinks,
        zoom: 1,
        center: ['50%', '50%']
      }]
    }, false);


    if (jointTarget) focusOnNode(jointTarget);
    else if (targetNodes.length > 0) focusOnNode(targetNodes[0].name);
  }

  function focusOnNode(name) {
    chart.dispatchAction({ type: 'focusNodeAdjacency', seriesIndex: 0, name });

    chart.setOption({
      series: [{ zoom: 1.6, center: ['50%', '50%'], animationDurationUpdate: 500 }]
    }, false);
  }

  function showNetworkData(data) {
    if (!chart) return;

    const nodeDegrees = {};
    data.links.forEach(l => {
      nodeDegrees[l.source] = (nodeDegrees[l.source] || 0) + 1;
      nodeDegrees[l.target] = (nodeDegrees[l.target] || 0) + 1;
    });

    const option = {
      title: {
        text: 'å½±äººåˆä½œç½‘ç»œ',
        subtext: `å½“å‰ç­›é€‰ï¼š${data.nodes.length} ä¸ªèŠ‚ç‚¹, ${data.links.length} æ¡å…³ç³»`,
        left: 'center',
        textStyle: { fontSize: 20, fontWeight: 'bold' }
      },
      tooltip: {
        trigger: 'item',
        formatter: function (params) {
          if (params.dataType === 'node') {
            const roles = Array.isArray(params.data.roles) ? params.data.roles : [];
            const roleCounts = params.data.roleCounts || {};
            const rolesText = roles.length ? roles.join(' / ') : (params.data.role || 'æœªçŸ¥');

            const countsText = roles.length
              ? roles.map(r => `${r}:${roleCounts[r] ?? 0}`).join(' , ')
              : '';

            return `
              <div class="tooltip-content">
                <strong>${params.data.name}</strong><br/>
                èº«ä»½: ${rolesText}<br/>
                ${countsText ? `èº«ä»½æ¬¡æ•°: ${countsText}<br/>` : ''}
                å‚ä¸ç”µå½±(å…¨é‡ç»Ÿè®¡): ${params.data.movieCount || 0}éƒ¨<br/>
                å¹³å‡è¯„åˆ†(å…¨é‡ç»Ÿè®¡): ${params.data.avgRating ? params.data.avgRating.toFixed(1) : 'N/A'}
              </div>
            `;
          }
          else {
            const movies = Array.isArray(params.data.movies) ? params.data.movies : [];
            let moviesInfo = '';
            if (movies.length) {
              moviesInfo += '<br/><br/>åŒºé—´å†…åˆä½œç”µå½±(æœ€å¤š5éƒ¨)ï¼š';
              movies.slice(0, 5).forEach(m => {
                moviesInfo += `<br/>${m.movie_name} (${m.year}) - ${m.rating}`;
              });
            }
            return `
              <div class="tooltip-content">
                <strong>${params.data.source} â†” ${params.data.target}</strong><br/>
                åŒºé—´å†…åˆä½œæ¬¡æ•°: ${params.data.value || 0} æ¬¡<br/>
                åŒºé—´å†…å‡åˆ†(ä»…å±•ç¤º): ${params.data.avgRating ? params.data.avgRating.toFixed(2) : 'N/A'}
                ${moviesInfo}
              </div>
            `;
          }
        }
      },
      series: [{
        type: 'graph',
        layout: document.getElementById('layoutSelect').value || 'force',
        force: { repulsion: 300, edgeLength: 120, gravity: 0.1, friction: 0.6 },
        roam: true,
        data: data.nodes.map(node => ({
          ...node,
          id: node.id || node.name,
          name: node.name,
          symbolSize: Math.max(15, Math.min(55, (nodeDegrees[node.id || node.name] || 1) * 2)),
          itemStyle: {
            color: getRoleColor(node.role),
            opacity: 0.85,
            borderColor: '#333',
            borderWidth: 1
          }
        })),
        links: data.links.map(link => ({
          ...link,
          lineStyle: {
            color: '#666',
            width: Math.max(1, Math.min(6, link.value || 1)),
            opacity: 0.7
          }
        })),
        label: {
          show: true,
          fontSize: 10,
          formatter: '{b}',
          backgroundColor: 'rgba(255,255,255,0.8)',
          padding: [2, 5]
        },
        emphasis: { focus: 'adjacency' }
      }]
    };

    chart.setOption(option, true);
  }

  function getRoleColor(role) {
    const colors = {
      'director': '#ff6b6b',
      'actor': '#4ecdc4',
      'writer': '#45b7d1',
      'other': '#96ceb4',
      'unknown': '#96ceb4'
    };
    return colors[role] || colors['other'];
  }

  function calculateStatistics(data) {
    const totalNodes = data.nodes.length;
    const totalLinks = data.links.length;

    const nodeMap = new Map();
    data.nodes.forEach(n => nodeMap.set(n.id || n.name, { degree: 0 }));

    data.links.forEach(l => {
      if (nodeMap.has(l.source)) nodeMap.get(l.source).degree++;
      if (nodeMap.has(l.target)) nodeMap.get(l.target).degree++;
    });

    const degrees = Array.from(nodeMap.values()).map(x => x.degree);
    const avgDegree = totalNodes ? degrees.reduce((a, b) => a + b, 0) / totalNodes : 0;
    const maxDegree = degrees.length ? Math.max(...degrees) : 0;

    const maxPossibleLinks = totalNodes * (totalNodes - 1) / 2;
    const density = (totalNodes > 1) ? (totalLinks / maxPossibleLinks) : 0;

    const ratings = data.links.map(l => l.avgRating).filter(r => r !== null && r !== undefined && !isNaN(r));
    const avgRating = ratings.length ? ratings.reduce((a, b) => a + b, 0) / ratings.length : 0;

    const insights = {
      highCoop: totalLinks > 150 ? 'æ£€æµ‹åˆ°å¤§é‡é«˜é¢‘åˆä½œå…³ç³»' : '',
      lowRating: avgRating < 6 ? 'å½“å‰ç­›é€‰èŒƒå›´å†…å­˜åœ¨æ˜æ˜¾ä½åˆ†åˆä½œæ¨¡å¼' : '',
      centralNode: maxDegree > 15 ? `æ ¸å¿ƒå½±äººåº¦ä¸­å¿ƒæ€§: ${maxDegree}` : ''
    };

    return { totalNodes, totalLinks, density, avgDegree, maxDegree, avgRating, insights };
  }

  function updateStatistics(data) {
    const stats = calculateStatistics(data);

    document.getElementById('networkStats').innerHTML = `
      <div class="stat-item ${stats.totalNodes > 100 ? 'highlight' : ''}">
        <span>æ€»èŠ‚ç‚¹æ•°:</span><span>${stats.totalNodes}</span>
      </div>
      <div class="stat-item ${stats.totalLinks > 200 ? 'highlight' : ''}">
        <span>æ€»è¾¹æ•°:</span><span>${stats.totalLinks}</span>
      </div>
      <div class="stat-item"><span>ç½‘ç»œå¯†åº¦:</span><span>${stats.density.toFixed(4)}</span></div>
      <div class="stat-item"><span>å¹³å‡åº¦:</span><span>${stats.avgDegree.toFixed(2)}</span></div>
      <div class="stat-item ${stats.maxDegree > 10 ? 'highlight' : ''}">
        <span>æœ€å¤§åº¦:</span><span>${stats.maxDegree}</span>
      </div>
      <div class="stat-item"><span>è¾¹å‡åˆ†(ä»…å±•ç¤º):</span><span>${stats.avgRating.toFixed(2)}</span></div>
    `;

    document.getElementById('keyInsights').innerHTML = `
      <div style="color:#e74c3c;margin-bottom:8px;">${stats.insights.highCoop ? 'ğŸ”´ ' + stats.insights.highCoop : ''}</div>
      <div style="color:#f39c12;margin-bottom:8px;">${stats.insights.lowRating ? 'ğŸŸ¡ ' + stats.insights.lowRating : ''}</div>
      <div style="color:#27ae60;">${stats.insights.centralNode ? 'ğŸŸ¢ ' + stats.insights.centralNode : ''}</div>
    `;
  }

  document.getElementById('layoutSelect').addEventListener('change', function () {
    applyFilters();
  });

  function exportImage() {
    if (!chart) return;
    const url = chart.getDataURL({ type: 'png', pixelRatio: 2, backgroundColor: '#fff' });
    const a = document.createElement('a');
    a.href = url;
    a.download = `å½±äººåˆä½œç½‘ç»œ_${new Date().toISOString().split('T')[0]}.png`;
    a.click();
  }

  // ===== ä¿ç•™ä½ çš„é¢„æµ‹åŠŸèƒ½ =====
  function predictMovie() {
    const directors = document.getElementById("directorsInput").value.split("/").map(s => s.trim()).filter(Boolean);
    const actors = document.getElementById("actorsInput").value.split("/").map(s => s.trim()).filter(Boolean);
    const wRelation = parseFloat(document.getElementById("relationWeight").value);

    const weights = {
      actor: (1 - wRelation) / 2,
      director: (1 - wRelation) / 2,
      relation: wRelation
    };

    document.getElementById("predictResult").innerText = "â³ æ­£åœ¨é¢„æµ‹ä¸­...";

    fetch("http://127.0.0.1:5000/predict", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ directors, actors, weights })
    })
      .then(res => res.json())
      .then(data => {
        document.getElementById("predictResult").innerHTML =
          `â­ é¢„æµ‹è¯„åˆ†ï¼š<b>${data.final_score}</b><br>
           æ¼”å‘˜è¯„åˆ†ï¼š${data.actor_score}<br>
           å¯¼æ¼”è¯„åˆ†ï¼š${data.director_score}<br>
           å…³ç³»è¯„åˆ†ï¼š${data.relation_score}`;
      })
      .catch(() => {
        document.getElementById("predictResult").innerText = "âŒ è¯·æ±‚å¤±è´¥ï¼ˆè¯·æ£€æŸ¥åç«¯ï¼‰";
      });
  }

  document.addEventListener('DOMContentLoaded', initChart);
</script>
</body>
</html>
